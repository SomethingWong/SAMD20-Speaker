#include <asf.h>
#define NUM_ELEMENTS 6

void simple_clock_init(void);
void output_8bit(int array[]);
void enable_tc_clocks(void);
void enable_tc_8bit(void);

int data[NUM_ELEMENTS] = {120, 120, 120, 10, 10, 10};


int main (void)
{
	enable_tc_clocks();
	for(;;){
		enable_tc_8bit();
		output_8bit(data);
	}
}
void simple_clock_init(void){//Simple Clock Initialization
	/* Various bits in the INTFLAG register can be set to one at startup.
	   This will ensure that these bits are cleared */
	SYSCTRL->INTFLAG.reg=SYSCTRL_INTFLAG_BOD33RDY | SYSCTRL_INTFLAG_BOD33DET | SYSCTRL_INTFLAG_DFLLRDY;	
	system_flash_set_waitstates(0);  //Clock_flash wait state=0
	SYSCTRL_OSC8M_Type temp=SYSCTRL->OSC8M;      /* for OSC8M initialization  */
	temp.bit.PRESC=0;    // no divide, i.e., set clock=8Mhz  (see page 170)
	temp.bit.ONDEMAND=1;    //  On-demand is true
	temp.bit.RUNSTDBY=0;    //  Standby is false
	SYSCTRL->OSC8M=temp;
	SYSCTRL->OSC8M.reg|=0x1u << 1;  //SYSCTRL_OSC8M_ENABLE bit=bit-1 (page 170)
	PM->CPUSEL.reg=(uint32_t)0;    // CPU and BUS clocks Divide by 1  (see page 110)
	PM->APBASEL.reg=(uint32_t)0;     // APBA clock 0= Divide by 1  (see page 110)
	PM->APBBSEL.reg=(uint32_t)0;     // APBB clock 0= Divide by 1  (see page 110)
	PM->APBCSEL.reg=(uint32_t)0;     // APBB clock 0= Divide by 1  (see page 110)
	PM->APBAMASK.reg|=01u<<3;   // Enable Generic clock controller clock (page 127)
	/* Software reset Generic clock to ensure it is re-initialized correctly */
	GCLK->CTRL.reg=0x1u << 0;   // Reset gen. clock (see page 94)
	while (GCLK->CTRL.reg&0x1u ) {  /* Wait for reset to complete */ }
	// Initialization and enable generic clock #0
	*((uint8_t*)&GCLK->GENDIV.reg)=0;  // Select GCLK0 (page 104, Table 14-10)
	GCLK->GENDIV.reg=0x0100;   		 // Divide by 1 for GCLK #0 (page 104)
	GCLK->GENCTRL.reg=0x030600;  		 // GCLK#0 enable, Source=6(OSC8M), IDC=1 (page 101)
}

void enable_tc_clocks(void)
{
	PM->APBCMASK.reg |= PM_APBCMASK_TC2;  	// PM_APBCMASK_TC2 is in the 19 position
	GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID_TC2_TC3;   		//  Setup in the CLKCTRL register
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_CLKEN;    	// enable it.
}
/* Configure the basic timer/counter for 8 bits*/
void enable_tc_8bit(void)
{

	Port *ports = PORT_INSTS;
	PortGroup *porA = &(ports->Group[0]);
	porA->PINCFG[13].reg = PORT_PINCFG_PMUXEN ;		// set to correct pin configuration
	porA->PMUX[6].reg = PORT_PMUX_PMUXO_E;
	
	Tc *tc = TC2;
	TcCount8 *tc8 = &(tc->COUNT8);
	/* Set up CTRLA */
	tc8->CTRLA.reg = TC_CTRLA_MODE_COUNT8|TC_CTRLA_PRESCALER_DIV1|TC_CTRLA_PRESCSYNC_PRESC|TC_CTRLA_WAVEGEN_NPWM;//counter mode, prescaler divider, prescaler prescync, waveform
	/*Enable TC*/
	tc8->CTRLA.reg |= TC_CTRLA_ENABLE;
}

void output_8bit(int array[]){
	Tc *tc = TC2;
	TcCount8 *tc8 = &(tc->COUNT8);

	for(;;){
		for(int i=0;i<NUM_ELEMENTS;i++){
			tc8->CC[1].reg=TC_COUNT8_CC_CC(array[i]);
		}
	}
}